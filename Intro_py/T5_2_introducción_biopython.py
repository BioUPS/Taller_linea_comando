# -*- coding: utf-8 -*-
"""Introducción_Biopython.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FobmWhsTk075Qutv29IsNANCxuVrJmww

# Tema: Introducción a Secuencias y Biopython

La terminal Python es diferente de la terminal GNU/Linux, y los comandos que funcionan en una normalmente no funcionarán en la otra. La terminal de Python está indicada por tres signos de mayor que >>>

Podemos definir una secuencia y acceder a una posición de la siguiente manera:
"""

x = "ATTGTACTAGTACGTACTTAG"
x

#Puedo econtrar una o varias bases en una posición específica, en este caso la primera posición = 0
x[0],x[5],x[10]

"""Por lo tanto, en Python las cadenas comienzan con la posición
0, entonces la segunda posición es 1, el tercero es 2, etcétera.
"""

try:
    import google.colab
    # Running on Google Colab, so install Biopython first
    !pip install biopython
except ImportError:
    pass
from Bio.Seq import Seq

adn = Seq("ATTGTACTAGTACGTACTTAG")
adn

""" Biopython toma el concepto de secuencia y lo convierte en un "objeto". La programación orientada a objetos es un paradigma en informática donde el concepto central es el "objeto" y existen "métodos" definidos que se pueden aplicar a estos objetos.

 Los objetos se definen como es de esperar, como unidades discretas que se ajustan a algún conjunto de parámetros o especificaciones definidas por una "clase". Por ejemplo, el objeto de secuencia.
x ->  definido anteriormente tiene algunas características similares a las que podría tener una molécula de ADN física.


"""

#Longitud de la cadena

len(adn)

#imprimiento diferentes nucleotidos por posición
print(adn)
print(adn[0])
print(adn[4])
print(adn[10])
print(adn[-1]) #ultima letra

"""### Recuento

 Proporciona un recuento de cada base o el patrón indicado
"""

print(adn.count("G"))
print(adn.count("C"))
print(adn.count("AT"))
print(adn.count("TA"))
print(adn)

"""# Dogma central
Consideremos ahora el dogma central de la biología molecular. El dogma central establece que la información biológica generalmente fluye del ADN al ARN y a las proteínas.

De manera similar, con Biopython podemos crear objetos correspondientes a secuencias de ADN, ARN y Proteínas. Podemos usar métodos en estos objetos para transcribir el ADN y traducir el ARN a una proteína.

Podemos transcribir nuestra secuencia de ADN, para ello vamos a definir la función:


"""

def transcribe(self):
    rna = self._data.replace('T', 'U')
    return Seq(rna, alphabet=RNAAlphabet())

# Trancribiendo la secuencia
arn = adn.transcribe()
print("ADN:", adn)
print("ARN:", arn)

"""Si importamos modulos y funciones, no será necesario definirlas, por ejemplo:"""

import os
import sys

from urllib.request import urlretrieve

import Bio
from Bio import SeqIO, SearchIO, Entrez
from Bio.SeqUtils import gc_fraction
from Bio.Blast import NCBIWWW
from Bio.Data import CodonTable

print("Python version:", sys.version_info)
print("Biopython version:", Bio.__version__)

"""# Traducción
Siguiendo con el mismo ejemplo discutido en la sección de transcripción anterior, ahora traduzcamos este ARNm a la secuencia de proteína correspondiente, nuevamente aprovechando uno de los métodos del objeto:
"""

#traduciendo desde ARNm
proteina = arn.translate()
print(proteina)

"""Imagen de código genético

"*" =STOP = UAG

https://biomodel.uah.es/biomodel-misc/codgen/codgen.png
"""

#Tanmbién se úede traducir desde la secuencia de adn de la cadena codificante
proteina1 = adn.translate()

print("proteína 1", proteina1)
print("proteína", proteina)
#Podemos visualizar la proteína generadas desde ARN y ADN codificante

"""# Inversión de secuencia

Podemos invertir una secuencia usando un paso negativo como -1

Al usar las opciones predeterminadas de inicio y parada, podemos obtener toda la secuencia a la inversa.


"""

inv = adn[::-1]
print("inverso", inv)
print("adn",adn)

"""#Complemento inverso

Debido a que el ADN suele ser bicatenario, podemos pensar que las secuencias de ADN son bicatenarias con la segunda hebra implicada. Es decir, aunque se nos dé una hebra de ADN, normalmente se da a entender que hay una segunda hebra asociada que es el complemento inverso de la primera.
La función reverse_complement() se utiliza en Biopython para obtener la secuencia complementaria invertida de una cadena de ADN, si queremos saber cómo se vería la cadena inversa.
"""

a1= adn.complement()
a2= adn.reverse_complement()

print("adn",adn)
print("a1 ",a1)
print("a2 ",a2)

complemento_invertido = adn.reverse_complement()

print(complemento_invertido)

"""también incluye un método de retrotranscripción para pasar del ARNm a la cadena codificante del ADN. Nuevamente, esta es una simple sustitución U → T:

back_transcribe()
"""

arn.back_transcribe()

"""# Subsecuencias
Para especificar una subcadena, debemos proporcionar una posición inicial y final. La subcadena resultante estará formada por los caracteres desde el principio hasta el final, pero sin incluirlos.
Es decir, la posición de parada es "no inclusiva" (no incluye la base de la posición de parada).
"""

d1 = adn[0:5]
print(d1)
print(adn)
# se incluye desde la primera (posición 0) hasta la quinta (posición 4), no incluye la sexta (5)
#Recordemos que la primera posición es el 0

"""La expresión d3 = adn[0:len(adn):3]  Es una sintaxis de segmentación de cadenas en Python.

Se utiliza para crear una nueva cadena que contiene cada tercer elemento de la cadena adn, comenzando desde el primer elemento.
"""

print("adn",adn)
d2 = adn[0:len(adn)]
print("d2",d2)
#cada tercer elemento
d3 = adn[0:len(adn):3]
print("d3", d3)
#cada cuarto elemento
d4 = adn[0:len(adn):4]
print("d4", d4)

"""# Calcular GC

El contenido de GC de una secuencia es el porcentaje de nucleótidos en la secuencia que son G o C. Probablemente la forma más sencilla de calcularlo es importar una función GC de otro módulo de Biopython, lastimosamente función GC fue eliminada.
La función GC() cuenta el número de bases de guanina (G) y citosina (C) en la secuencia y divide ese número por la longitud total de la secuencia. Luego, multiplica el resultado por 100 para obtener el porcentaje de contenido de GC.

¿¿¿Cómo lo haría usted???
Entonces lo podemos hacer de la siguiente manera:
"""

G = adn.count("G")
C = adn.count("C")

GC = ((G+C)/len(adn))*100
print(GC)

100*(adn.count("G")+adn.count("C"))/len(adn)

"""Podemos usar la función gc-fraccion"""

gc_fraction(adn)

"""Tenga en cuenta que el uso de la Bio.SeqUtils.gc_fraction()función debería hacer frente automáticamente a secuencias de casos mixtos y al nucleótido ambiguo S, que significa G o C."""

adx = "ATCGCTAGAGACTAATASTGCGAATTCAAT"
gc_fraction(adx)

"""#  Convertir objetos Seq en cadenas

Si realmente solo necesita una cadena simple, por ejemplo para escribir en un archivo o insertarla en una base de datos, entonces esto es muy fácil de obtener:
"""

adn_chain = str(adn)
print(adn_chain)

"""Generando un formato Fasta

Esta línea de código construye un registro en formato FASTA simple
"""

fasta1 = "adn-cadena\n%s\n" % adn
print(fasta1)

"""# Concatenar o agregar secuencias

Se pueden concatenar dos Seqobjetos sumándolos:
"""

adn + adx

"""Biopython no verifica el contenido de la secuencia y no generará una excepción si, por ejemplo, concatenas una secuencia de proteína y una secuencia de ADN (lo cual probablemente sea un error).

# MAYÚSCULAS A MINÚSCULAS
"""

adx.lower()

adx.upper()

#genero una cadena con mayúsculas y minúsculas
adn_m = "actagATTCGAGAatc"

adn_m.upper()

"""Comparing Seq objects

La comparación de secuencias es en realidad un tema muy complicado y no existe una manera fácil de decidir si dos secuencias son iguales. El problema básico es que el significado de las letras de una secuencia depende del contexto: la letra "A" podría ser parte de una secuencia de ADN, ARN o proteína. Biopython puede rastrear el tipo de molécula, por lo que comparar dos Seqobjetos podría significar considerar esto también.
"""

adn == adx

gen= Seq("GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCA")

gen.translate()

"""Buscando la posición de un patrón con gen.find y otros"""

gen.find("AG")

gen.find("AGTCG")
#find devuelve -1 cuando no hay coincidencias

gen.rindex("AG")
# rfind y rindex también buscan coincidencias

for index, sub in gen.search(["CC", "AG", "TC"]):
  print(index, sub)

#muestra la posición en donde coincide la búsqueda

len(gen)